use std::str::FromStr;
use reikna::factor::quick_factorize;
use num_bigint::{BigInt, BigUint};
use num_traits::{One, Zero};

fn mod_inv(a: &BigInt, m: &BigInt) -> Option<BigInt> {
    let (g, x, _) = extended_gcd(a.clone(), m.clone());
    if g.is_one() {
        Some((x % m + m) % m)
    } else {
        None // modular inverse does not exist
    }
}

fn extended_gcd(a: BigInt, b: BigInt) -> (BigInt, BigInt, BigInt) {
    if a.is_zero() {
        (b.clone(), BigInt::zero(), BigInt::one())
    } else {
        let (g, x, y) = extended_gcd(&b % &a, a.clone());
        (g, y - (b / a) * x.clone(), x)
    }
}

fn decrypt (p: BigInt, n: BigInt, e: BigInt, ciphertext: BigInt) -> BigInt {
    let q = &n/&p;
    let totient = (&p - BigInt::one()) * (&q - BigInt::one());
    let d = mod_inv(&e, &totient).unwrap();
    ciphertext.modpow(&d, &n)
}

fn rsa_encrypt(plaintext: &BigUint, e: &BigUint, n: &BigUint) -> BigUint {
    // Calculate ciphertext: C â‰¡ P^e mod n
    plaintext.modpow(e, n)
}
fn main() {
    let number: u64 = 184196244864397;
    let ans = quick_factorize(number);
    println!("{:?}", &ans);
    let p: BigInt = BigInt::from_str("97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637").unwrap();
    let q = BigInt::from_str("92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559").unwrap();
    let e = BigInt::from_str("65537").unwrap();
    let totient: BigInt = (p - BigInt::one()) * (q - BigInt::one());
    let d= mod_inv(&e, &totient).unwrap();
    println!("d is : {}", d);

    let pt = BigUint::from_str("71473861342641469823706695197831157839263842650833208806307454043829577214430495340675290752668244266876657439877027761033774981590891325859521131553").unwrap();
    let public_exponent = BigUint::from_str("3").unwrap();
    let modulus = BigUint::from_str("29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331").unwrap();

    let ciphertext = rsa_encrypt(&pt, &public_exponent, &modulus);
    println!("Ciphertext: {}", ciphertext);

    let plaintext = decrypt(BigInt::from_str("153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433").unwrap(), BigInt::from_str("23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239").unwrap(), BigInt::from_str("65537").unwrap(), BigInt::from_str("9926743059483366312571722659243149289303219670532095455534170636428632312734469624407475443037323504163589180112754492087158175470586681251671605357315664860516332887578062349310622975668436236431521624730858138587393728809606691990293467784742193372698430148430787676969954585171572331213484454808100028222918106854521181045068072594497715700542589531600555891147221627108335167339418895550918884588208050976492573241505501397655453371574835716725202609137041379483291129598975673939342451267730139350910365382345458271429480380897867801139372094495723466447310605851577031712591990425449213945081274245917360497454").unwrap());
    println!("Plaintext: {}", plaintext);
    // Convert the integer to a hexadecimal representation
    let hex_string = format!("{:x}", &plaintext);
    println!("{}", hex_string);
    // Convert the hexadecimal string to bytes
    let hex_bytes = hex::decode(hex_string).expect("Failed to decode hex");

    // Convert the bytes back to a string (message)
    let message = String::from_utf8(hex_bytes).expect("Failed to convert bytes to string");
    let test = String::from_utf8(vec![120]).expect("");
    println!("{}", test);
    println!("Message: {}", message);
}
